
---
author: 
- William Findlay
title: 3007 Final Exam Review 
date: \today
bibliography: /home/housedhorse/.bibs/uni.bib
csl: /home/housedhorse/.bibs/ieee.csl
header-includes:
  \usepackage{float}
  \let\origfigure\figure
  \let\endorigfigure\endfigure
  \renewenvironment{figure}[1][2] {
      \expandafter\origfigure\expandafter[H]
  } {
      \endorigfigure
  }
output:
  pdf_document:
    number_sections: true
    fig_crop: true
    fig_caption: true
    keep_tex: false
---
\newpage
\tableofcontents
\newpage

# Definitions
Define the following terms and provide examples or sample code as appropriate.

## Imperative vs Declarative
### Imperative
- Series of instructions
- Iterative functions
- Command driven, statement oriented
- Procedural
  - C
  - Pascal
  - Assembly
- Object oriented
  - C++
  - Java

### Declarative
- No side effects
- Focus on relations
- "What to get" instead of "How to get"
- Order of statements *shouldn't* matter
- Examples:
  - SQL
  - Prolog
  - Regex

## Scope vs Visibility
### Scope
- The set of expressions for which the variable *exists*
- In lexical scoping
  - variables in the scope we were *defined* in
  - and local variables
  - who uses this?
    - C-family languages
    - Scheme
    - Algol
- In dynamic scoping
  - variables in the scope we were *called* in
  - and local variables
  - who uses this?
    - early LISP
    - APL
    - BASH

### Visibility
- The set of expressions for which the variable *can be reached*
- If we **declare a local variable** with the *same name* as a variable in enclosing scope
  - that enclosing scope variable is now hidden
  - all references to *name* are to our locally scoped variable instead

## Lexical Scope vs Dynamic Scope
### Lexical
- Function scope is enclosed in the scope which *defined us*
  - if you can't find a binding, recursively search in the function that defined you

### Dynamic
- Function scope is enclosed in the scope which *called us*
  - if you can't find a binding, recursively search in the function that called you

## Free Variables
- **Used locally** but **bound in an enclosing scope**
- In the following example:
  ```{Scheme}
  (define (f x y)
    (define z 2)
    (define (g)
      (* x y z)
    )
  )
  ```
  - `x,y,z` are free variables in `(g)`
  - `(g)` *looks them up* in its *enclosing scope*, `(f)`

## Applicative Order Evaluation vs Normal Order Evaluation
### Applicative Order Evaluation
- **Strict evaluation**
- Evaluate an expression *before* it is passed in as an argument
  - go as deep as you can until you hit primitives, then evaluate and go back
  - as deep into the nest as possible and work backwards
  - e.g.,
    ```{Scheme}
    (double (* (+ 1 3) 4))
    (double (* 4 4))
    (double 16)
    (* 16 2)
    32
    ```

### Normal Order Evaluation
- **Lazy evaluation**
- Evaluate an expression *only* when its value is needed
  - first **expand**, then **reduce**
  - e.g.,
    ```{Scheme}
    (double (* (+ 1 3) 4))
    (* (* (+ 1 3) 4) 2)
    (* (* 4 4) 2)
    (* 16 2)
    32
    ```

## Special Forms
- **Exceptions** to the usual evaluation order
  - they have their own evaluation rules
  - e.g., take the first argument without evaluating right away, evaluate the second symbol right away
- Use constructs like `(delay foo)`, `(force foo)` behind the scenes

## Tail Recursion
- **Linear iterative processes** in Scheme
- No *deferred operations*
  - **recusrive call** is the **last operation** of the procedure
- In Scheme, recursion is *tail optimized*
  - this means that it will run in *constant space*
  - number of steps will **grow linearly**, but memory will **remain constant**
- Even though the *program* is still recursive, the *process* is linear iterative because of tail-recursion optimization
- E.g., to compute a factorial using tail recursion, we do the following:
  ```{Scheme}
  (define (factorial x)
    (define (iter prod i)
      (if (> i x)
        prod
        (iter (* i prod) (+ i 1))
      )
    )
    (iter 1 1)
  )
  ```
- To compute a factorial using normal recursion, we would do the following instead:
  ```{Scheme}
  (define (factorial x)
    (if (= x 1)
      x
      (* x (factorial - x 1))
    )
  )
  ```

## First Class and Higher Order Procedures
### First Class Procedures
- When procedures (functions) behave like variables
  - procedures can be *passed as arguments* into other procedures
  - or they can be *returned* from another procedure
- E.g.,
  ```{Scheme}
  (define (f g)
    (g 2)
  )
  (define (h x)
    (+ x 3)
  )
  (f h) ; this would yield (+ 2 3), which evaluates to 5
  ```
- This is how *closures* work
  - more on this in a following subsection

### Higher Order Procedures
- A procedure which *accepts one or more procedure(s)* as argument(s)
- In other words, a procedure which *uses* the **first class procedures** property of a language
- In the above codeblock, `(f g)` is an example of a **higher order procedure**

## Closures
- When a nested function is *returned* by its **enclosing scope**
- In practice, the returned function is typically a `lambda` (anonymous procedure)
- E.g.,
  ```{Scheme}
  (define (multBy x)
    (lambda (y)(* x y)) ; lambda captures the free variable x
  )

  ((multBy 12) 3) ; 36

  (define (double) (multBy 2))
  (define (triple) (multBy 3))

  (double 2) ; 4
  (triple 2) ; 6
  ```

## Abstraction Barriers
- **Hide implementation** within complex procedures
  - user does not need to know how they work
  - they need only be guaranteed that they *will* work
- Prevents pollution of the global namespace
- Prevents excess free variables

## Referential Transparency
- The idea that *references* can be substituted for their values without changing result of an expression
- Purely functional languages are referentially transparent
- Imperative languages are *by definition* **not** referentially transparent
